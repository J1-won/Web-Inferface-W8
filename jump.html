<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Jumping Cat</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Jersey+10&display=swap" rel="stylesheet">
<style>
  @font-face {
    font-family: 'DosSammul';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_eight@1.0/DOSSaemmul.woff') format('woff');
    font-weight: normal; font-display: swap;
  }
  html { font-size: 2rem; scroll-behavior: smooth; }
  body, h1, h2, h3, p, ul { margin:0; padding:0; }
  body.bg {
    background: url('universe.jpg') center top no-repeat;
    background-size: cover;
    /* JS에서 backgroundPositionY를 계속 업데이트해 “올라가는” 느낌 */
  }
  h1{
    font-family:"Jersey 10",sans-serif;font-weight:400;font-size:4rem;text-align:center;
    padding:200px 0 20px 0;
    text-shadow:7px 7px 0 white,-7px -7px 0 white,7px -7px 0 white,-7px 7px 0 white;
    filter:drop-shadow(5px 5px 0 #73564b);
    z-index:2; position:relative;
  }
  h3{
    font-family:'DosSammul',sans-serif;font-weight:400;font-size:1rem;text-align:center;
    padding-bottom:70px;
    text-shadow:2px 2px 0 white,-2px -2px 0 white,2px -2px 0 white,-2px 2px 0 white;
    filter:drop-shadow(2px 2px 0 #73564b); z-index:2; position:relative;
  }

  #overlay{
    display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:9;
  }
  #rulePopup{
    display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    width:620px; background:#fff; border:5px solid #000; box-shadow:6px 6px 0 #333;
    padding:50px 30px; font-family:'DosSammul'; line-height:1.3rem;
    font-size:0.7rem; color:#111; z-index:10;
  }
  #rulePopup h2{ text-align:center; margin-bottom:40px; font-size:1.6rem; }
  #rulePopup ul{ text-align:left; padding-left:20px; }
  #rulePopup button{
    display:block; margin:40px auto 0 auto; padding:15px 15px; border:3px solid #000; background:#fff;
    font-family:'DosSammul'; font-size:0.5rem; cursor:pointer; filter:drop-shadow(3px 3px 0 #555);
  }
  #rulePopup button:hover{ background:#000; color:#fff; }

  /* 상단 UI */
  #timer{
    position:fixed; top:40px; right:40px; z-index:8;
    font-family:"Jersey 10",sans-serif; font-size:2rem;
    text-shadow:3px 3px 0 white,-3px -3px 0 white,3px -3px 0 white,-3px 3px 0 white;
  }
  #hearts{
    position:fixed; top:50px; left:40px; z-index:8;
  }
  #hearts img{ width:60px; margin-right:5px; image-rendering:pixelated; }

  /* 게임 스테이지 */
  #stage{
    position:relative; width:100%; height:100vh; overflow:hidden; z-index:1;
  }
  .cloud{
    position:absolute; image-rendering:pixelated; user-select:none; pointer-events:none;
    transform:translate(-50%,-50%);
  }
  #cat{
    position:absolute; width:150px; transform:translate(-50%,-50%); image-rendering:pixelated;
  }
  #goalX{
    position:absolute; width:100px; transform:translate(-50%,-50%); image-rendering:pixelated;
  }

  /* 디버그(제스처 미리보기) - 필요시 */
  #camBox{
    position:fixed; top:50px; left:50%; transform:translateX(-50%);
    width:240px; padding:8px; background:rgba(255,255,255,.9);
    border:3px solid #333; box-shadow:4px 4px 0 #666;
    font-family:'DosSammul'; font-size:12px; image-rendering:pixelated; z-index:8;
    display:none; /* 필요하면 block으로 바꿔서 보면서 튜닝 */
  }
  #camBox canvas{ display:block; width:220px; height:160px; margin:0 auto; }
  #camBox .cap{ text-align:center; margin-top:4px; }
  /* 오존층(반투명 안개 레이어) */
/* 기존 #ozone 전체 교체 */
#ozone{
  position:absolute;        /* ← 월드(스테이지) 기준 */
  width:100vw;               /* 취향대로 */
  height:70vh;
  pointer-events:none;
  z-index:4;
  display:none;
  opacity:0;
  background:rgba(120,180,255,0.22);
  transition:opacity .35s ease;
  backdrop-filter: blur(6px);
  box-shadow: 0 12px 40px rgba(80,130,255,0.25);
}
</style>
</head>
<body class="bg">
  <h1>Jumping Cat!</h1>
  <h3>야옹이와 함께 높이 올라가볼까요?</h3>

  <div style="text-align:center;">
    <img src="unicat.png" id="startThumb" style="width:420px; cursor:pointer; padding-top:100px" />
  </div>

  <div id="overlay"></div>
  <div id="rulePopup"></div>

  <div id="timer" style="display:none;">TIME 40</div>
  <div id="hearts" style="display:none;">
    <img src="heart.png"><img src="heart.png"><img src="heart.png">
  </div>

  <!-- (선택) 캠 디버그 -->
  <div id="camBox">
    <canvas id="camViz" width="220" height="160"></canvas>
    <div class="cap" id="gestureText">tilt / nod</div>
  </div>

  <div id="stage" style="display:none;">
    <div id="ozone" aria-hidden="true"></div>
  </div>

  <!-- 오디오 요소들 -->
  <audio id="gotItemsAudio" autoplay muted>
    <source src="got_items.mp3" type="audio/mpeg">
  </audio>
  <audio id="blinkAudio">
    <source src="blink.mp3" type="audio/mpeg">
  </audio>
  <audio id="jumpAudio" loop>
    <source src="jump.mp3" type="audio/mpeg">
  </audio>
  <audio id="addAudio">
    <source src="add.mp3" type="audio/mpeg">
  </audio>
  <audio id="wrongAudio">
    <source src="wrong.mp3" type="audio/mpeg">
  </audio>
  <audio id="successAudio">
    <source src="success.mp3" type="audio/mpeg">
  </audio>
  <audio id="failedAudio">
    <source src="failed.mp3" type="audio/mpeg">
  </audio>
  <audio id="clickAudio">
		<source src="blink.mp3" type="audio/mpeg">
	  </audio>

  <script>
    /* ========= 전역 ========= */
    let gameActive = false;
    let timerId = null, timeLeft = 40;
    let lives = 3;
    let stage, catEl, goalEl;

    // 오디오 요소들
    const gotItemsAudio = document.getElementById('gotItemsAudio');
    const blinkAudio = document.getElementById('blinkAudio');
    const jumpAudio = document.getElementById('jumpAudio');
    const addAudio = document.getElementById('addAudio');
    const wrongAudio = document.getElementById('wrongAudio');
    const successAudio = document.getElementById('successAudio');
    const failedAudio = document.getElementById('failedAudio');

    // 음악 재생 함수들
    function playSound(audioElement) {
      audioElement.currentTime = 0;
      audioElement.play().catch(() => {});
    }

    function enableSound() {
      gotItemsAudio.muted = false;
      jumpAudio.muted = false;
    }

    // 페이지 로드 시 got_items.mp3 자동 재생
    document.addEventListener('DOMContentLoaded', () => {
      gotItemsAudio.volume = 0.5;
      gotItemsAudio.play().catch(() => {
        console.log('got_items.mp3 자동 재생 차단됨');
      });
    });

    // 사용자 상호작용 시 음소거 해제
    document.addEventListener('click', enableSound, { once: true });
    document.addEventListener('keydown', enableSound, { once: true });
    document.addEventListener('touchstart', enableSound, { once: true });
    document.addEventListener('mousemove', enableSound, { once: true });

    // 모든 버튼 클릭 시 blink.mp3 재생하는 공통 함수
    function playBlinkSound(){
      playSound(blinkAudio);
    }
    let scrollY = 0;                // 월드 Y (위로 갈수록 +)
    let targetHeight = 6000;
    let clouds = [];
    let spawnY = 200;
    const CLOUD_SPAWN_GAP = 220;
    const MAX_LIVES = 3;
    // 오존층 판정/두께 조절용 상수 (전역 상단 어딘가에 추가)
const CAT_HALF_H = 60;          // 고양이 반높이(대략) — 필요시 55~70 사이 조정
const OZONE_TOUCH_MARGIN = 40;  // 가장자리 여유값(조금만 걸쳐도 인식)
const OZ_BAND_RATIO = 0.26;     // 오존층 두께(화면 높이 대비 비율) ← 높이 바꾸려면 이 값만 조정
// 오존 라벨(오존층에 붙는 텍스트)
let ozoneLabelEl = null;
let inOzone = false;   // 고양이가 오존층 안에 있는지 상태
    
    /* === 오존층(월드의 특정 밴드) === */
    let ozoneEl = null;
    let ozoneReady = false;         // targetHeight 계산 후 true
    let ozoneWyStart = 0;           // 오존층 시작 월드Y
    let ozoneWyEnd   = 0;           // 오존층 끝   월드Y
    const OZ_SCREEN_OFFSET = 100;   // 화면에서 조금 더 위로(픽셀) 올려서 보이게
    
    /* === 오존층 진입 안내문구 === */
    let ozoneNoticeEl = null;
    
    /* 배경 이미지 실제 표시 높이 */
    let bgDisplayHeight = 3000;
    function computeBgDisplayHeight(naturalW, naturalH){
      const vw = window.innerWidth;
      return naturalH * (vw / naturalW);
    }
    
    /* ===== 제스처 옵션 ===== */
    const MIRROR_INPUT = true;
    const EMA_A   = 0.12;
    const GESTURE_COOLDOWN = 600;
    const NEUTRAL_TILT = 6;
    const NEUTRAL_NOD  = 6;
    
    let rollEMA = 0, pitchEMA = 0;
    let tiltReady = true, nodReady = true;
    
    const cloudImgs = Array.from({length:9},(_,i)=>`c${i+1}.png`);
    const GOLD_IMG = 'gc.png';
    const CAT_IMG  = 'backcat.png';
    const GOAL_IMG = 'crystal.png';
    
    /* ========= 룰 팝업 ========= */
    function renderRules(){
      const popup = document.getElementById('rulePopup');
      popup.innerHTML = `
        <h2>!Rule!</h2>
        <ul>
          <li>머리를 왼쪽/오른쪽으로 기울이면 그 방향으로 점프한다.</li>
          <li>키보드 방향키(←, ↑, →)로도 조작 가능!</li>
          <li>황금 구름은 착지 시 하트가 하나 살아남!</li>
          <li>우측 상단 타이머가 끝나기 전까지 꼭대기의 크리스탈을 찾으면 성공~</li>
        </ul>
        <button onclick="playBlinkSound(); startGame()">&gt; 게임 시작하기 &lt;</button>
      `;
    }
    function showRules(){
      renderRules();
      document.getElementById('overlay').style.display = 'block';
      document.getElementById('rulePopup').style.display = 'block';
    }
    document.getElementById('startThumb').addEventListener('click', () => {
      playSound(clickAudio);
      showRules();
    });
    
    /* ========= 시작 ========= */
    function startGame(){
      gameActive = true;

      // 게임 시작 시 jump.mp3 자동 재생
      jumpAudio.volume = 0.4;
      jumpAudio.play().catch(() => {
        console.log('jump.mp3 자동 재생 차단됨');
      });
    
      // 배경 기본 스타일 (bottom anchor)
      document.body.classList.remove('bg');
      document.body.style.backgroundImage  = "url('sky.jpg')";
      document.body.style.backgroundSize   = '100% auto';
      document.body.style.backgroundRepeat = 'no-repeat';
      document.body.style.backgroundPosition = 'center bottom';
      document.body.style.backgroundColor  = '#03040a';
    
      // UI 전환
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('rulePopup').style.display = 'none';
      document.getElementById('timer').style.display = 'block';
      document.getElementById('hearts').style.display = 'block';
      document.getElementById('stage').style.display  = 'block';
    
      // 스테이지/오존층 참조
      stage = document.getElementById('stage');
      // 오존층 엘리먼트
ozoneEl = document.getElementById('ozone');

// ⬇️ 오존 라벨 준비 (오존층에 "붙어" 다님)
ozoneLabelEl = document.getElementById('ozoneLabel');
if (!ozoneLabelEl) {
  ozoneLabelEl = document.createElement('div');
  ozoneLabelEl.id = 'ozoneLabel';
  ozoneLabelEl.textContent = '오존층 진입!';
  Object.assign(ozoneLabelEl.style, {
    position: 'absolute',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    zIndex: '5',            // 오존층(4) 위에 보이도록
    display: 'none',        // 처음엔 숨김
    fontFamily: 'DosSammul, sans-serif',
    fontSize: '1.1rem',
    padding: '8px 14px',
    color: '#0b3b6f',
    textShadow: '2px 2px 0 #fff, -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff',
    pointerEvents: 'none'
  });
  stage.appendChild(ozoneLabelEl);
}
    
      // 스테이지 초기화: 오존층은 남기고 나머지 자식만 제거
      Array.from(stage.children).forEach(n => { if (n.id !== 'ozone') n.remove(); });
      delete stage.dataset.cloudsBuilt;
    
      // 오존층은 "처음부터 존재"
      ozoneEl.style.display = 'block';
      ozoneEl.style.opacity = '0.85';
    
      // 타이틀 위치 조정
      const h1 = document.querySelector('h1');
      h1.style.position = 'fixed';
      h1.style.top = '-50px';
      h1.style.left = '50%';
      h1.style.transform = 'translateX(-50%)';
      h1.style.fontSize = '2rem';
      h1.style.zIndex = '5';
      h1.style.pointerEvents = 'none';
      const sub = document.querySelector('h3'); if (sub) sub.style.display = 'none';
      document.getElementById('startThumb').style.display = 'none';
    
      // 스테이지 z-index
      stage.style.zIndex = '3';
    
      // 초기화 값
      lives = 3; timeLeft = 40; scrollY = 0; inOzone = false;
      document.getElementById('hearts').innerHTML = '<img src="heart.png"><img src="heart.png"><img src="heart.png">';
    
      // 오존층 진입 안내문구 엘리먼트 준비(고정 상단 중앙)
      if (!ozoneNoticeEl){
        ozoneNoticeEl = document.createElement('h3');
        ozoneNoticeEl.id = 'ozoneNotice';
        ozoneNoticeEl.textContent = '오존층 진입!';
        Object.assign(ozoneNoticeEl.style, {
          position:'fixed', top:'500px', left:'50%', transform:'translateX(-50%)',
          zIndex:'7', display:'none',
          fontFamily:'DosSammul, sans-serif', fontSize:'1.2rem',
          padding:'6px 12px',
          textShadow:'2px 2px 0 white, -2px -2px 0 white, 2px -2px 0 white, -2px 2px 0 white',
          filter:'drop-shadow(2px 2px 0 #73564b)'
        });
        document.body.appendChild(ozoneNoticeEl);
      } else {
        ozoneNoticeEl.style.display = 'none';
      }
    
      // 고양이
      catEl = document.createElement('img');
      catEl.id = 'cat';
      catEl.src = CAT_IMG;
      catEl.style.transform = 'translate(-50%,-50%) scaleX(1)';
      stage.appendChild(catEl);
    
      // 목표물
      goalEl = document.createElement('img');
      goalEl.id = 'goalX';
      goalEl.src = GOAL_IMG;
      goalEl.style.width = '50px';
      stage.appendChild(goalEl);
    
      // sky.jpg 로드 후 월드 세팅
      const sky = new Image();
      sky.src = 'sky.jpg';
      sky.onload = ()=>{
        bgDisplayHeight = computeBgDisplayHeight(sky.naturalWidth, sky.naturalHeight);
        targetHeight = Math.max(window.innerHeight + 800, bgDisplayHeight);
    
       // (교체) 오존층 밴드 월드좌표 계산
const bandHeightWorld = Math.round(window.innerHeight * OZ_BAND_RATIO); // 두께를 비율로
ozoneWyStart = Math.round(targetHeight * 0.50); // 시작 위치(필요하면 0.45~0.6 사이로 조정)
ozoneWyEnd   = ozoneWyStart + bandHeightWorld;
ozoneReady   = true;
    
        // 구름 생성
        clouds = [];
        for(let y=spawnY; y<=targetHeight-120; y += CLOUD_SPAWN_GAP){
          spawnCloudRow(y);
        }
    
        // 목표 X (꼭대기 근처)
        goalEl.dataset.wx = (Math.random()*0.5 + 0.25) * window.innerWidth;
        goalEl.dataset.wy = targetHeight - 80;
    
        // 시작 위치: 가장 낮은 구름 위
        const startCloud = clouds.reduce((best, c) => (!best || c.y < best.y) ? c : best, null);
        if (startCloud){
          catWorldX = (startCloud.wx ?? startCloud.x);
          catWorldY = startCloud.y + 60;
          catVX = 0; catVY = 0; onAir = false;
          attachedCloud = startCloud;
          attachOffsetX = catWorldX - (startCloud.wx ?? startCloud.x);
          scrollY = Math.max(0, catWorldY - window.innerHeight * 0.45);
        } else {
          // fallback
          catWorldX = window.innerWidth * 0.5;
          catWorldY = 120;
          catVX=0; catVY=0; onAir=false;
        }
    
        // 한 프레임에 배경/오존 먼저 정렬
        updateBackground();
        updateOzoneWorld();
        updateOzoneNotice(); // 초기 상태 반영
    
        // 제스처/키/타이머 시작
        setupFaceGestures();
        window.addEventListener('keydown', onKey);
    
        updateTimer();
        timerId = setInterval(()=>{
          if(!gameActive) { clearInterval(timerId); return; }
          timeLeft--;
          updateTimer();
          if (timeLeft <= 0) { endGame(false, '시간 초과'); }
        }, 1000);
    
        requestAnimationFrame(gameLoop);
      };
    }
    
    /* ========= 구름 스폰 ========= */
    function rnd(min,max){ return min + Math.random()*(max-min); }
    function spawnCloudRow(y){
      const wobbleAmp = Math.min(140, 25 + y/5);
      const wobbleSpdBase = rnd(0.6, 1.2);
      const count = 1 + Math.floor(Math.random()*3); // 1~2
      const margin = 240;
      const minGap = 180;
      const pickedX = [];
    
      for (let i=0; i<count; i++){
        let tries=0, x=null;
        while (tries++ < 20){
          const cand = rnd(margin, window.innerWidth - margin);
          if (pickedX.every(px => Math.abs(px - cand) >= minGap)) { x=cand; break; }
        }
        if (x==null) continue;
        pickedX.push(x);
    
        const img = Math.random()<0.05 ? GOLD_IMG : cloudImgs[Math.floor(Math.random()*cloudImgs.length)];
        clouds.push({
          x, y, img,
          gold: (img===GOLD_IMG),
          amp: wobbleAmp * Math.random(),
          phase: Math.random()*Math.PI*2,
          speed: wobbleSpdBase * (0.7 + Math.random()*0.8)
        });
      }
    }
    
    /* ========= 물리/렌더 ========= */
    let catWorldX=0, catWorldY=0, catVX=0, catVY=0, onAir=true;
    const GRAV = -0.0007;
    const JUMP_DX = 220;   // “한 칸” 좌우 이동량
    const JUMP_DY = 250;   // “한 칸” 위로 이동량
    let attachedCloud = null;      // 현재 서있는 구름
    let attachOffsetX = 0;
    
    function worldToScreenY(wy){ return window.innerHeight - (wy - scrollY); }
    function updateTimer(){ document.getElementById('timer').textContent = 'TIME ' + (timeLeft<10?('0'+timeLeft):timeLeft); }
    
    function updateBackground(){
      // 바닥(0) → 꼭대기(1)
      const scrollRange = Math.max(1, targetHeight - window.innerHeight);
      const progress    = Math.min(1, Math.max(0, scrollY / scrollRange));
      const maxBgOffset = Math.max(0, bgDisplayHeight - window.innerHeight);
      const bgTopPx = -Math.round(maxBgOffset * (1 - progress));
      document.body.style.backgroundPosition = `center ${bgTopPx}px`;
    }
    
    function gameLoop(){
      if(!gameActive) return;
    
      // 구름 좌우 흔들림
      const t = performance.now()/1000;
      clouds.forEach(c=>{
        c.wx = c.x + Math.sin(t*c.speed + c.phase)*c.amp;
      });
    
      // 착지 상태면 발판 구름과 함께 X 동기화
      if (!onAir && attachedCloud){
        const cx = attachedCloud.wx ?? attachedCloud.x;
        catWorldX = cx + attachOffsetX;
      }
    
      // 중력/이동
      catVY += GRAV * 16;
      catWorldY += catVY * 16;
      catWorldX += catVX * 16;
      catVX *= 0.94;
    
      // 착지 체크
      const footY = catWorldY - 50;
      let landed = false;
      for(const c of clouds){
        const cy = c.y;
        const cx = c.wx ?? c.x;
        const w = 180, h = 50;
        const withinX = Math.abs(catWorldX - cx) < w*0.45;
        const nearY   = (footY <= cy + h*0.25) && (footY >= cy - h*0.25) && (catVY<0);
        if (withinX && nearY){
          catWorldY = cy + 60;
          catVY = 0;
          if (onAir){ tiltReady = true; nodReady = true; }
          onAir = false; landed = true;
    
          attachedCloud = c;
          attachOffsetX = catWorldX - (c.wx ?? c.x);
    
          if (c.gold && lives < MAX_LIVES){
            lives++;
            document.getElementById('hearts').innerHTML = '<img src="heart.png">'.repeat(lives);
            playSound(addAudio); // 황금구름 밟을 때 add.mp3 재생
          }
          break;
        }
      }
      if (!landed){
        onAir = true;
        attachedCloud = null;
      }
    
      // 화면 아래로 추락
      if (worldToScreenY(catWorldY) > window.innerHeight + 120){
        playSound(wrongAudio); // 추락 시 wrong.mp3 재생
        loseLife(); if(!gameActive) return;
        const safe = findNearestBelowCloud(catWorldX, scrollY+200);
        catWorldX = (safe?.x || window.innerWidth*0.5);
        catWorldY = (safe?.y || scrollY+300) + 120;
        catVY=0; onAir=false; tiltReady = true; nodReady = true;
        attachedCloud = safe || null;
        attachOffsetX = attachedCloud ? (catWorldX - (attachedCloud.wx ?? attachedCloud.x)) : 0;
      }
    
      // 카메라(스크롤) — 고양이 중심
      const targetScroll = Math.max(0, catWorldY - window.innerHeight*0.45);
      scrollY += (targetScroll - scrollY) * 0.12;
    
      // 배경/오존층/문구 업데이트
      updateBackground();
      updateOzoneNotice();
      updateOzoneWorld();
      
    
      // 렌더
      catEl.style.left = catWorldX + 'px';
      catEl.style.top  = worldToScreenY(catWorldY) + 'px';
    
      renderClouds();
      const gx = parseFloat(goalEl.dataset.wx), gy = parseFloat(goalEl.dataset.wy);
      goalEl.style.left = gx + 'px';
      goalEl.style.top  = worldToScreenY(gy) + 'px';
    
      // 목표 도달
      const dx = Math.abs(catWorldX - gx);
      const dy = Math.abs(catWorldY - gy);
      if (dx < 70 && dy < 70){ endGame(true, '오존층 회복 물건(X)에 도달!'); return; }
    
      requestAnimationFrame(gameLoop);
    }
    
    function renderClouds(){
      if (!stage.dataset.cloudsBuilt){
        clouds.forEach((c,idx)=>{
          const el = document.createElement('img');
          el.className = 'cloud';
          el.src = c.img;
          el.style.width = c.gold ? '200px' : '240px';
          el.dataset.index = idx;
          stage.appendChild(el);
          c.el = el;
        });
        stage.dataset.cloudsBuilt = '1';
      }
      clouds.forEach(c=>{
        const el = c.el;
        const x = c.wx ?? c.x;
        el.style.left = x + 'px';
        el.style.top  = worldToScreenY(c.y) + 'px';
      });
    }
    
    /* ========= 점프 ========= */
    function jump(dir){
      if (!gameActive || onAir) return;
    
      if (dir === 'left')  { catEl.style.transform = 'translate(-50%,-50%) scaleX(-1)'; }
      if (dir === 'right') { catEl.style.transform = 'translate(-50%,-50%) scaleX(1)'; }
    
      const targetX = catWorldX + (dir==='left'?-JUMP_DX: dir==='right'?JUMP_DX:0);
      const targetY = catWorldY + JUMP_DY;
      const t = 18; // 프레임 가정
    
      catVX = (targetX - catWorldX) / (t*16);
      catVY = (targetY - catWorldY) / (t*16);
      onAir = true;
      attachedCloud = null;
    }
    
    function findNearestBelowCloud(x, yTop){
      let best=null, bestScore=1e9;
      for(const c of clouds){
        if (c.y < yTop) continue;
        const dx = (c.wx??c.x) - x;
        const dy = c.y - yTop;
        const score = Math.abs(dx) + dy*0.5;
        if (score < bestScore){ bestScore = score; best = c; }
      }
      return best;
    }
    
    /* ========= 라이프/엔딩 ========= */
    function loseLife(){
      lives--;
      document.getElementById('hearts').innerHTML = '<img src="heart.png">'.repeat(lives);
      if (lives <= 0){ endGame(false, '추락으로 기절…'); }
    }
    
    function endGame(success, reason){
      gameActive = false;
      if (timerId) { clearInterval(timerId); timerId=null; }
      teardownFaceGestures();
      window.removeEventListener('keydown', onKey);

      // 게임 종료 시 배경 음악 정지
      jumpAudio.pause();
      jumpAudio.currentTime = 0;

      document.getElementById('overlay').style.display = 'block';
      const p = document.getElementById('rulePopup');
      p.style.display = 'block';

      // 게임 결과에 따른 음악 재생
      if (success) {
        playSound(successAudio);
      } else {
        playSound(failedAudio);
      }

      const title = success ? 'GAME CLEAR!' : 'GAME OVER :(';
      const msg = success
        ? '오존층이 환경 오염으로 파괴되고 있어요. <br>야옹이가 거쳐온 오존층을 지키기 위해 <br>다같이 노력해주세요!'
        : `파괴된 오존층을 지켜내지 못하게 되었어요... 대신 여러분들이 오존층을 지켜주세요!`;
    
      p.innerHTML = `
        <h2 style="text-align:center; font-size:1.6rem; margin-bottom:28px;">${title}</h2>
        <p style="font-size:0.9rem; text-align:center;">${msg}</p>
        <div style="display:flex; justify-content:center; gap:20px; margin-top:30px;">
          <button style="margin:0;" onclick="playBlinkSound();  location.href='index.html'">&gt; 메뉴로 이동 &lt;</button>
          <button style="margin:0;" onclick="playBlinkSound(); startGame()">&gt; 다시 하기 &lt;</button>
        </div>
      `;
    }
    
    function backToMenu(){
      gameActive = false;
      if (timerId) { clearInterval(timerId); timerId=null; }
      teardownFaceGestures();
      window.removeEventListener('keydown', onKey);

      // 메뉴로 돌아갈 때 배경 음악 정지
      jumpAudio.pause();
      jumpAudio.currentTime = 0;

      document.getElementById('overlay').style.display = 'none';
      renderRules();
      document.getElementById('rulePopup').style.display = 'none';
    
      document.getElementById('timer').style.display = 'none';
      document.getElementById('hearts').style.display = 'none';
      document.getElementById('stage').style.display = 'none';
    
      const h1 = document.querySelector('h1');
      h1.style.fontSize = '4rem'; h1.style.transform = 'translateY(0)';
      const h3 = document.querySelector('h3'); if (h3) h3.style.display = 'block';
      const thumb = document.getElementById('startThumb'); thumb.style.display = 'inline';
    
      if (ozoneNoticeEl) ozoneNoticeEl.style.display = 'none';
    }
    
    /* ========= 키보드 ========= */
    function onKey(e){
      if (!gameActive) return;
      if (e.key === 'ArrowLeft'){ e.preventDefault(); jump('left'); }
      if (e.key === 'ArrowRight'){ e.preventDefault(); jump('right'); }
      if (e.key === 'ArrowUp'){ e.preventDefault(); jump('up'); }
    }
    
    /* ========= 얼굴 제스처 ========= */
    let camPrev=null, camViz=null, vizCtx=null;
    let mpFace=null, mpCamera=null;
    const TILT_TH = 20, NOD_TH = 10;
    let lastGestureAt = 0;
    
    function setupFaceGestures(){
      camViz = document.getElementById('camViz');
      vizCtx = camViz.getContext('2d', { willReadFrequently:true });
    
      if (!camPrev){
        camPrev = document.createElement('video');
        Object.assign(camPrev, { autoplay:true, playsInline:true, muted:true });
        camPrev.style.display = 'none';
        document.body.appendChild(camPrev);
      }
      loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js')
      .then(()=>loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js'))
      .then(()=>{
        // eslint-disable-next-line no-undef
        mpFace = new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
        mpFace.setOptions({ maxNumFaces:1, refineLandmarks:false, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
        mpFace.onResults(onFaceResults);
    
        // eslint-disable-next-line no-undef
        mpCamera = new Camera(camPrev, {
          onFrame: async ()=>{ await mpFace.send({image:camPrev}); },
          width: 320, height: 240
        });
        mpCamera.start();
      }).catch(err=>{ console.warn('FaceMesh 로드 실패:', err); });
    }
    
    function teardownFaceGestures(){
      try{ if (mpCamera && mpCamera.stop) mpCamera.stop(); }catch(e){}
      mpCamera=null; mpFace=null;
      if (camPrev && camPrev.srcObject){
        camPrev.srcObject.getTracks().forEach(t=>t.stop());
        camPrev.srcObject = null;
      }
    }
    
    function onFaceResults(res){
      vizCtx.clearRect(0,0,camViz.width,camViz.height);
      if (!(res.multiFaceLandmarks && res.multiFaceLandmarks.length) || !gameActive) return;
    
      const lm = res.multiFaceLandmarks[0];
      const L = lm[33], R = lm[263], N = lm[1];
    
      const dx = (R.x - L.x), dy = (R.y - L.y);
      const rollRaw  = Math.atan2(dy, dx) * 180/Math.PI;
      const pitchRaw = (((L.y + R.y)/2) - N.y) * 200;
    
      const rollFix = MIRROR_INPUT ? -rollRaw : rollRaw;
    
      rollEMA  = rollEMA  * (1-EMA_A) + rollFix  * EMA_A;
      pitchEMA = pitchEMA * (1-EMA_A) + pitchRaw * EMA_A;
    
      const now = performance.now();
      if (now - lastGestureAt < GESTURE_COOLDOWN) return;
      if (onAir) return;
    
      if (tiltReady){
        if (rollEMA >  TILT_TH){ jump('right'); tiltReady=false; lastGestureAt=now; return; }
        if (rollEMA < -TILT_TH){ jump('left');  tiltReady=false; lastGestureAt=now; return; }
      } else if (Math.abs(rollEMA) <= NEUTRAL_TILT){ tiltReady = true; }
    
      if (nodReady){
        if (pitchEMA > NOD_TH){ jump('up'); nodReady=false; lastGestureAt=now; return; }
      } else if (Math.abs(pitchEMA) <= NEUTRAL_NOD){ nodReady = true; }
    }
    
    function loadScript(src){
      return new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=src; s.onload=()=>res(); s.onerror=rej; document.head.appendChild(s);
      });
    }
    
    // 초기 룰 준비
    renderRules();
    
    /* ========= 오존층 월드→스크린 변환 ========= */
    function updateOzoneWorld(){
      if (!ozoneEl || !ozoneReady) return;
      const wyCenter = (ozoneWyStart + ozoneWyEnd) * 0.5;
      const syCenter = worldToScreenY(wyCenter);
      ozoneEl.style.display = 'block';
      ozoneEl.style.top = (syCenter - OZ_SCREEN_OFFSET) + 'px'; // 화면에서 조금 더 위로
      ozoneEl.style.opacity = '0.85';
    }
    
    // ⬇️ 이 함수만 교체
// ⬇️ 이 함수만 교체
function updateOzoneNotice(){
  if (!ozoneReady || !ozoneEl || !ozoneNoticeEl) return;

  // 감도 강화: 아주 살짝만 닿아도 인식되도록 여유폭을 크게
  const EXTRA_TOUCH = 170; // ← 더 넉넉한 여유
  const catTop    = catWorldY + CAT_HALF_H + OZONE_TOUCH_MARGIN + EXTRA_TOUCH;
  const catBottom = catWorldY - CAT_HALF_H - OZONE_TOUCH_MARGIN - EXTRA_TOUCH;

  // 오존 밴드와 겹치면 true (끝에 스치기만 해도)
  const overlaps = !(catBottom > ozoneWyEnd || catTop < ozoneWyStart);

  if (overlaps){
    // 오존층 화면 위치에 라벨 "붙이기"
    const r = ozoneEl.getBoundingClientRect();
    ozoneNoticeEl.style.display   = 'block';
    ozoneNoticeEl.style.position  = 'fixed';
    ozoneNoticeEl.style.left      = '50%';
    ozoneNoticeEl.style.top       = (r.top + r.height * 0.5) + 'px';
    ozoneNoticeEl.style.transform = 'translateX(-50%)';

    // 0.5초 간격 깜빡임 (너무 과하지 않게 1 ↔ 0.35)
    if (!ozoneNoticeEl._blinkId){
      ozoneNoticeEl.style.opacity = '1';
      ozoneNoticeEl._blinkId = setInterval(()=>{
        // inside일 때만 부드럽게 깜빡임 유지
        if (ozoneNoticeEl.style.display === 'block'){
          ozoneNoticeEl.style.opacity = (ozoneNoticeEl.style.opacity === '1' ? '0.35' : '1');
        }
      }, 500);
    }
  } else {
    // 겹치지 않으면 숨김 + 깜빡임 정리
    ozoneNoticeEl.style.display = 'none';
    ozoneNoticeEl.style.opacity = '1';
    if (ozoneNoticeEl._blinkId){
      clearInterval(ozoneNoticeEl._blinkId);
      ozoneNoticeEl._blinkId = null;
    }
  }
}
    </script>
</body>
</html>